# -*- coding: utf-8 -*-


# Big F*n simulator.
# Create a grid fin using lofted rectangles.  Too slow.

import FreeCAD
import math
import Draft, Part
import collections


BezierPoint = collections.namedtuple("BezierPoint", ['z', 'control1', 'r', 'control2'])


def toRad(angle):
    return angle * math.pi * 2.0 / 360.0

# mm
PIVOT_RADIUS = 200.0
# starting points
INNER_RADIUS = 4550.0
OUTER_RADIUS = INNER_RADIUS + PIVOT_RADIUS * 2.0
# outer Y calculated from bezier curve
outerR = []

THICKNESS = 4.0


GRID_H = 3000.0

GRID_SPACE = GRID_H / 6.0
WIDTH = GRID_SPACE * 5.0
# radians covered by the width
WIDTH_ANGLE = WIDTH / OUTER_RADIUS
# height without notched corners
GRID_H2 = GRID_SPACE * 5.0
# grid starts 2 pivot radiuses below pivot
GRID_TOP = -PIVOT_RADIUS * 2.0
GRID_BOTTOM = GRID_TOP - GRID_H
NOTCH_Z = GRID_BOTTOM + 350.0
# intersections per strip
INTERSECTIONS = 11.0
# side intersections
SIDE_INTERSECTIONS = 7.0
BOTTOM_INTERSECTIONS = 6.0
doc = App.activeDocument()
DEPTH = Draft.Vector(INNER_RADIUS - OUTER_RADIUS, 0, 0)
ARCH_H = 100.0


def getOuterR(z):
    return outerR[int(z - GRID_BOTTOM)]

def getInnerR(z):
    return outerR[int(z - GRID_BOTTOM)] + DEPTH.x

def polarToXYZ(angle, radius, z):
    x = radius * math.cos(angle)
    y = -radius * math.sin(angle)
    return Draft.Vector(x, y, z)

def XYZToPolar(xyz):
    angle = math.atan2(-xyz.y, xyz.x)
    radius = math.hypot(xyz.x, xyz.y)
    return Draft.Vector(angle, radius, xyz.z)

lineSegments = 16

# make an arc between 2 points on the inner radius, with a height given
# easier than using Draft.makeCircle
def makeArch(point1, point2, height, extraPoint, notchIt):
    result = []
    steps = lineSegments
    if extraPoint:
        steps = steps + 1
    
    # convert to polar to do the radius deformations
    point1Polar = XYZToPolar(point1)
    point2Polar = XYZToPolar(point2)
    # need difference between inner radius & point radius, in case the point arguments aren't on the inner radius
    radius1Diff = point1Polar.y - getInnerR(point1Polar.z)
    radius2Diff = point2Polar.y - getInnerR(point2Polar.z)

    for i in range(steps):
        fraction = float(i) / float(steps - 1)
        x = fraction * (point2Polar.x - point1Polar.x) + point1Polar.x
        #y = fraction * (point2Polar.y - point1Polar.y) + point1Polar.y
        z = fraction * (point2Polar.z - point1Polar.z) + point1Polar.z
        y = getInnerR(z)
        deform = math.sin(fraction * math.pi) * height
        radiusDiff = fraction * (radius2Diff - radius1Diff) + radius1Diff
        xyzResult = polarToXYZ(x, y + radiusDiff, z)
        
        
        # need to add arch deformation in XYZ coords
        if not notchIt or z >= NOTCH_Z:
            result.append(Draft.Vector(xyzResult.x + deform, xyzResult.y, xyzResult.z))
    return result

# always the outer radius
def makeLine(point1, point2, extraPoint, notchIt):
    result = []
    steps = lineSegments
    if extraPoint:
        steps = steps + 1


    # convert to polar to do the radius deformations
    point1Polar = XYZToPolar(point1)
    point2Polar = XYZToPolar(point2)

    
    for i in range(steps):
        fraction = float(i) / float(steps - 1)
        x = fraction * (point2Polar.x - point1Polar.x) + point1Polar.x
        #y = fraction * (point2Polar.y - point1Polar.y) + point1Polar.y
        z = fraction * (point2Polar.z - point1Polar.z) + point1Polar.z
        y = getOuterR(z)
        if not notchIt or z >= NOTCH_Z:
            result.append(polarToXYZ(x, y, z))
    return result






def makeSlice(x1, y1, x2, y2, thickness, intersections, counter):
    # points of the grid intersections
    crossPoints = []
    # points for the inner, serrated edge
    innerPoints = []
    # points for the outer, smooth edge
    outerPoints = []
    
        
    # calculate the crossPoints
    for i in range(int(intersections)):
        angle = x1 + i / (intersections - 1) * (x2 - x1)
        y = y1 + i / (intersections - 1) * (y2 - y1)

        if y >= GRID_BOTTOM and y <= GRID_TOP:
            point = polarToXYZ(angle, getOuterR(y), y)
            crossPoints.append(point)
    
    # is the strip visible?
    if len(crossPoints) >= 2:
        # fill points between the crossPoints
        for i in range(len(crossPoints) - 1):
            line = makeLine(crossPoints[i], 
                crossPoints[i + 1], 
                i == len(crossPoints) - 1,
                counter == 4)
            outerPoints.extend(line)
            arc = makeArch(crossPoints[i] + DEPTH, 
                crossPoints[i + 1] + DEPTH, 
                ARCH_H, 
                i == len(crossPoints) - 1,
                counter == 4)
            innerPoints.extend(arc)
    

        # convert the points into 4 wires
        points0 = []
        points1 = []
        points2 = []
        points3 = []
        taperZ0 = GRID_TOP - GRID_SPACE * 1.5
        taperZ1 = GRID_TOP - GRID_SPACE
        taperZ2 = GRID_TOP
        THICKNESS2 = 12.0
        THICKNESS1 = 8.0
        for i in range(len(outerPoints)):
            thickness2 = thickness

            if (counter == 8 and outerPoints[i].z >= taperZ0) or \
                (counter == 9 and outerPoints[i].z >= taperZ1):
                thickness2 = thickness2 * (1.0 + THICKNESS2 * \
                    (outerPoints[i].z - taperZ0) / \
                    (taperZ2 - taperZ0))

            if counter == 10 and outerPoints[i].z >= taperZ1:
                thickness2 = thickness2 * (1.0 + THICKNESS1 * \
                    (outerPoints[i].z - taperZ0) / \
                    (taperZ2 - taperZ0))

            if counter == 11 and outerPoints[i].z >= taperZ1:
                thickness2 = thickness2 * (1.0 + THICKNESS1 * \
                    (outerPoints[i].z - taperZ1) / \
                    (taperZ2 - taperZ1))

            points0.append(outerPoints[i] - thickness2)
            points1.append(outerPoints[i] + thickness2)
            points2.append(innerPoints[i] + thickness2)
            points3.append(innerPoints[i] - thickness2)


        line0 = Draft.makeWire(points0, closed=False, face=False, support=None)
        line1 = Draft.makeWire(points1, closed=False, face=False, support=None)
        line2 = Draft.makeWire(points2, closed=False, face=False, support=None)
        line3 = Draft.makeWire(points3, closed=False, face=False, support=None)
        
        loft = doc.addObject('Part::Loft','Loft')
        loft.Sections = [ line0, line1, line2, line3 ]
        loft.Solid = False
        loft.Ruled = True
        loft.Closed = True

        result = { 'inner':innerPoints, 'outer':outerPoints }
        return result
        
    else:
        return None



def makeNotch(innerPoint1, innerPoint2, outerPoint1, outerPoint2, thickness):
    line0 = Draft.makeWire(makeArch(innerPoint1 - thickness, innerPoint2 - thickness, ARCH_H, True, False), False, False, False)
    line1 = Draft.makeWire(makeArch(innerPoint1 + thickness, innerPoint2 + thickness, ARCH_H, True, False), False, False, False)
    line2 = Draft.makeWire(makeLine(outerPoint1 + thickness, outerPoint2 + thickness, True, False), False, False, False)
    line3 = Draft.makeWire(makeLine(outerPoint1 - thickness, outerPoint2 - thickness, True, False), False, False, False)
    
    loft = doc.addObject('Part::Loft','Loft')
    loft.Sections = [ line0, line1, line2, line3 ]
    loft.Solid = False
    loft.Ruled = True
    loft.Closed = True
    return

def makeSolid(point1, point2, point3, point4, thickness):
    line0 = Draft.makeWire([point1 - thickness, point2 - thickness, point3 - thickness, point4 - thickness], closed=True, face=True, support=None)
    line1 = Draft.makeWire([point1 + thickness, point2 + thickness, point3 + thickness, point4 + thickness], closed=True, face=True, support=None)
    loft = doc.addObject('Part::Loft','Loft')
    loft.Sections = [ line0, line1 ]
    loft.Solid = False
    loft.Ruled = True
    loft.Closed = True
    return

    
    



def makeGrid():
    # chopped corners
    cornerW = WIDTH_ANGLE / (INTERSECTIONS - 1)
    cornerH = GRID_H2 / (INTERSECTIONS - 1)
    # start at double the height
    y = GRID_BOTTOM - GRID_H
    counter = 0
    diagonals1 = []
    diagonals2 = []
    while y < GRID_TOP:
        #if True:
        #    y = 0
        x2 = WIDTH_ANGLE / 2
        y2 = y + GRID_H2
        intersections = INTERSECTIONS
        if counter == 7:
            x2 = x2 - cornerW
            y2 = y2 - cornerH
            intersections = intersections - 1
        elif counter == 10:
            x2 = -WIDTH_ANGLE / 2 + cornerW * 3
            y2 = y + cornerH * 3
            intersections = 4.0

        slice = makeSlice(-WIDTH_ANGLE / 2, 
            y, 
            x2, 
            y2, 
            Draft.Vector(0.0, THICKNESS / 2, THICKNESS / 2), 
            intersections,
            counter)
        diagonals1.append(slice)

        x2 = -WIDTH_ANGLE / 2
        y2 = y + GRID_H2
        intersections = INTERSECTIONS
        if counter == 7:
            x2 = x2 + cornerW
            y2 = y2 - cornerH
            intersections = intersections - 1
        elif counter == 10:
            x2 = WIDTH_ANGLE / 2 - cornerW * 3
            y2 = y + cornerH * 3
            intersections = 4.0

        slice = makeSlice(WIDTH_ANGLE / 2, 
            y, 
            x2, 
            y2, 
            Draft.Vector(0.0, THICKNESS / 2, -THICKNESS / 2), 
            intersections,
            counter)
        diagonals2.append(slice)
        y = y + GRID_SPACE
        counter = counter + 1

    # create the notch with diagonal points
    #print 'len=', len(diagonals1), ' diagonals1=', diagonals1[4]
    #print 'len=', len(diagonals2), ' diagonals2=', diagonals2[4]

    makeNotch(diagonals1[4]['inner'][0], 
        diagonals1[3]['inner'][0],
        diagonals1[4]['outer'][0], 
        diagonals1[3]['outer'][0],
        Draft.Vector(0.0, THICKNESS / 2, 0.0))
    makeNotch(diagonals2[4]['inner'][0], 
        diagonals2[3]['inner'][0],
        diagonals2[4]['outer'][0], 
        diagonals2[3]['outer'][0],
        Draft.Vector(0.0, THICKNESS / 2, 0.0))
    makeSolid(diagonals1[4]['inner'][0], 
        diagonals1[4]['outer'][0], 
        diagonals2[4]['outer'][0],
        diagonals2[4]['inner'][0],
        Draft.Vector(0.0, 0.0, -THICKNESS / 2))


    # fillers
    y1 = GRID_TOP - cornerH
    y2 = GRID_TOP - cornerH * 3
    makeSlice(WIDTH_ANGLE / 2 - cornerW, 
        y1, 
        WIDTH_ANGLE / 2 - cornerW, 
        y2, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        2, 
        -1)
    makeSlice(-WIDTH_ANGLE / 2 + cornerW, 
        y1, 
        -WIDTH_ANGLE / 2 + cornerW, 
        y2, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        2, 
        -1)
    makeSlice(WIDTH_ANGLE / 2 - cornerW * 3, 
        y1, 
        WIDTH_ANGLE / 2 - cornerW * 3, 
        y2, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        2, 
        -1)
    makeSlice(-WIDTH_ANGLE / 2 + cornerW * 3, 
        y1, 
        -WIDTH_ANGLE / 2 + cornerW * 3, 
        y2, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        2, 
        -1)




    # outline

    makeSlice(-WIDTH_ANGLE / 2, 
        GRID_BOTTOM + GRID_H2, 
        -WIDTH_ANGLE / 2, 
        GRID_BOTTOM, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        SIDE_INTERSECTIONS - 1, 
        -1)
    makeSlice(WIDTH_ANGLE / 2, 
        GRID_BOTTOM + GRID_H2, 
        WIDTH_ANGLE / 2, 
        GRID_BOTTOM, 
        Draft.Vector(0.0, THICKNESS / 2, 0.0), 
        SIDE_INTERSECTIONS - 1, 
        -1)
    makeSlice(-WIDTH_ANGLE / 2, 
        GRID_BOTTOM, 
        WIDTH_ANGLE / 2, 
        GRID_BOTTOM, 
        Draft.Vector(0.0, 0.0, THICKNESS / 2), 
        BOTTOM_INTERSECTIONS, 
        -1)



# create bezier curve lookup table for the outer Y
def initOuter():
    z = GRID_BOTTOM
    bezierPoints = [
        BezierPoint(GRID_BOTTOM,                 0.0, OUTER_RADIUS,                         0.0),
        BezierPoint(GRID_TOP - GRID_SPACE * 2.0, 0.0, OUTER_RADIUS,                         0.0),
        BezierPoint(GRID_TOP,                    0.0, OUTER_RADIUS + PIVOT_RADIUS,    0.0),
        BezierPoint(PIVOT_RADIUS,                PIVOT_RADIUS, INNER_RADIUS + PIVOT_RADIUS, 0.0)
    ]
    #bezierPoints = [
        #BezierPoint(GRID_BOTTOM,  0.0, OUTER_RADIUS, 0.0),
        #BezierPoint(PIVOT_RADIUS, 0.0, OUTER_RADIUS, 0.0)
    #]
    for i in range(len(bezierPoints) - 1):
        point1 = bezierPoints[i]
        point2 = bezierPoints[i + 1]
        y0 = point1.r
        y1 = point1.r + point1.control2
        y2 = point2.r + point2.control1
        y3 = point2.r
        z0 = point1.z
        z1 = point2.z
        for z in range(int(z0), int(z1)):
            t = (float(z) - z0) / (z1 - z0)
            tpow2 = t * t
            tpow3 = t * t * t
            invt = 1.0 - t
            invtpow2 = invt * invt
            invtpow3 = invt * invt * invt
            outerR.append(  invtpow3 * y0
                + 3.0 * t     * invtpow2 * y1
                + 3.0 * tpow2 * invt     * y2 
                +       tpow3            * y3)



    testPoints = []
    z0 = bezierPoints[0].z
    z1 = bezierPoints[len(bezierPoints) - 1].z
    for i in range(int(z1) - int(z0)):
        testPoints.append(Draft.Vector(outerR[i], 0.0, z0 + i))


    Draft.makeWire(testPoints, closed=False, face=False, support=None)



initOuter()

#makeGrid()


#cylinder = doc.addObject("Part::Cylinder","Cylinder")
#cylinder.Label = "Cylinder"
#cylinder.Radius = PIVOT_RADIUS
#cylinder.Height = 1700
#cylinder.Placement = App.Placement(
#    App.Vector(INNER_RADIUS, cylinder.Height / 2, 0.0),
#    App.Rotation(App.Vector(1,0,0),90))






